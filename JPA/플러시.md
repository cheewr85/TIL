- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
- 쌓아둔 SQL을 변경사항과 데이터베이스를 맞추는 작업

### 플러시 발생
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)
- 보내고 commit을 해야함

### 영속성 컨텍스트를 플러시하는 방법
- 테스트 할 때 알아둬야함
- em.flush() → 직접 호출
- 트랜잭션 커밋 → 플러시 자동 호출
- JPQL 쿼리 실행 → 플러시 자동 호출
- 코드로 본다면 아래와 같음, 이 경우는 쿼리를 미리 반영하거나 보고 싶을 경우 사용함
- 즉 flush를 통해서 즉시 flush 과정이 진행됨
- 1차 캐시는 그대로 유지가 됨 영속성 컨텍스트내에 쓰기 지연 SQL 저장소와 변경감지, 바뀐 것을 데이터베이스에 반영이 되는 과정임
```java
						// 영속

            Member member = new Member(200L, "member200");
            em.persist(member);
            
            // 강제 호출, flush 매커니즘 바로 실행됨=
            em.flush();
```

### JPQL 쿼리 실행시 플러시가 자동으로 호출되는 경우
![one](/img/JPA/Flush/one.png)

- JPQL은 SQL을 직접 실행하는 것이기 때문에 위의 persist를 해서 DB에 없다면 JPQL 자체가 에러가 됨
- 그래서 JPQL 쿼리 실행시 무조건 flush를 날림, 그래서 memberA,B,C가 자동으로 반영 된 것

### 플러시 모드 옵션
![one](/img/JPA/Flush/two.png)

- 상황에 따라서 플러시 모드 옵션을 쓸 수 있음

### 플러시
- 영속성 컨텍스트를 비우지 않음
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
- 트랜잭션이라는 작업 단위가 중요 → 커밋 직전에만 동기화 하면 됨