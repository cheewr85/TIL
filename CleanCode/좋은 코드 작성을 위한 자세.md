### 그밖의 좋은 코드 작성을 위한 Tip7
- 정적 팩토리 메서드
    - 정적 팩토리 메서드란 객체 생성을 담당하는 public static 메서드를 말함
    - 생성자와 비교하면 몇가지 장점이 있음
    - 메서드 이름을 활용해 생성되는 객체의 특성을 표현할 수 있음
    - 아래와 같이 Color 클래스에서 각 생상 모델명을 표현한 코드가 있음, 하지만 이는 변수명만으로 구분은 가능하지만, 객체 생성 방식의 명시성이 확실히 떨어짐, 그래서 이를 정적 팩토리 메서드를 이용해 표현해 가능함
    ```java
    Color rgbColor = new Color(255, 155, 100);
    Color cmykColor = new Color(0, 39, 61, 0);
    Color hsvColor = new Color(21, 60.8, 100.0);
    ```
    - 아래와 같이 객체 생성 코드를 정적 팩토리 메서드를 이용할 수 있음
    ```java
    Color rgbColor = Color.fromRGB(int red, int green, int blue);
    Color cmykColor = Color.fromCMYK(int cyan, int magenta, int yellow, int black);
    Color hsvColor = Color.fromHSV(double hue, double saturation, double value);
    ```
    - 생성자를 통한 객체 생성보다 명시성이 향상된 것을 알 수 있음, 메서드 이름만으로 어떤 Color 객체가 생성될지 알 수 있음
    - 그렇지만 생성자 수가 한 개 혹은 두 개 정도밖에 되지 않을때는 굳이 사용하지 않아도 됨
    - 객체 생성 방식이 여러가지 있는 경우 또는 같은 시그니처의 생성자를 정의할 필요가 있을 때 정적 팩토리 메서드를 정의하는 것이 좋음
    - 빌더패턴도 남용하는 경우가 많은데, 빌더 패턴은 생성자나 정적 팩토리 메서드의 매개변수가 너무 많을 경우, 대부분 인자가 선택적 인자인 경우에 사용하는 것이 바람직함
    - 생성된 객체에 대한 정보를 메서드 이름에 담을 수 있다는 것이 장점인데 같은 이름을 사용하는 것은 메서드 이름으로 인한 명시성 향상에 별 도움이 되지 않으므로 아래의 케이스대로 처리하는게 좋음
    ```java
    valueOf(int i);
    valueOf(long l);
    valueOf(float f);
    valueOf(double d);
    ```
    ```java
    fromInt(int i);
    fromLong(long l);
    fromFloat(float f);
    fromDouble(double d);
    ```

- 다형성은 만병통치약?
    - if-else, switch는 초보적인 것 같고 다형성이 항상 정답인 것처럼 보이지만 그렇지 않음
    - 인터페이스를 구현한 클래스가 3개 있다고 할 때, 만약 인터페이스의 메서드가 하나 추가된다면 이를 구현한 세 개의 클래스 모두에 변경이 발생함, 만약 절차 지향적이라고 하면 if  또는 switch로 분기하는 방식이면 조건만 추가하면 되는 문제임
    - 그러므로 변경이 어디서 이루어지느냐에 따라서 인터페이스를 구현한 클래스가 추가될 가능성이 큰 지 아니면 인터페이스에 새로운 함수가 추가될 가능성이 더 큰지를 따져볼 수 있음

- YAGNI(You aren't gonna need it)
    - 클래스나 함수는 실제로 필요할 때 만드는 게 좋음
    - 객체지향, 디자인 패턴을 접하고 무리하게 확장성을 고려하며 쓰지도 않을 클래스나 함수를 미리 만드는 경향이 있는데 개발 중엔 새로운 요구 사항이나 설계 변경이 자주 발생하므로 미리 만들어봐야 헛수고임
    - 모든 예측에는 틀릴 가능성이 내포됨, 현재 데이터 현재 소프트웨어 시스템을 기반으로 결정을 내릴 때 올바른 방향으로 향할 가능성이 훨씬 큼
    - 그러므로 미리 만들어서 쓰면 매우 쓸모 없고 버그가 될 수도 있고 없애고 싶어도 못 없앨수도 있음

- 유연한 대응
    - 현재의 필요에 의해서만 개발하란 말이 변화에 대응할 필요 자체가 없다는 것은 아님
    - 미래에 설계가 바뀔 수 있음을 고려해 개발하되, 프로그램에 어떤 변화가 발생할 것이고 어떤 구체적인 기능이 필요하게 될 것인지 까지 설계에 당장 담지 말라는 의미
    - 그러면 미래의 설계가 바뀔 수 있음을 고려한 개발은 무엇인가?
    - **여러 클린코드 작성법과 SRP, DIP 등의 객체지향 개발 원칙을 바탕으로 프로그램을 설계, 개발하는 것**
    - **프로그램이 이런 설계/개발 원칙을 기반으로 작성되어야 나중에 변경이 필요할 때 유연하게 대응할 수 있음**

- Rule of Three
    - 여러 리팩토링 기법과 디자인 패턴 같은 설계 기법이 코드 중복을 피하고자 나타남, 중복된 코드가 많을수록 코드 변경 횟수가 많아져 유지보수에 좋지 않기 때문임
    - 중복 코드를 너무 민감하게 대비할 필요는 없음, 어떤 코드가 중복될 것을 예상된다거나 한 두개 정도의 코드 중복이 보인다고 서둘러 코드를 리팩토링하는 것은 자칫 잘못된 설계의 원인이 될 수 있음
    - 보통 중복 코드가 세 개 이상 발견되는 경우에 리팩토링을 하면 잘못된 설계를 피할 수 있다고 함, 이 때쯤 되면 중복을 없애기 위해 공통으로 뽑아낼 요소가 명확해지기 때문임

    > 하나의 기준일 뿐 필수 원칙은 아닙니다. 특히 기존 프로그램을 점진적으로 리팩터링하는 경우에는 위 원칙을 크게 신경 쓰지 않아도 되겠습니다. 신규 프로젝트 개발과 비교하면 비즈니스 요구사항이 어느 정도 정해져 있기 때문입니다

- 중복 허용
    - 코드가 애매하게 반복되어 공통 요소를 뽑기 어려운 경우에는 중복을 어느 정도 허용하는 게 나을 수 있음, 애매한 중복 코드를 없애려다 도리어 코드 구조가 복잡해지는 경우가 발생함
    - 중복 해결보다 코드의 단순성과 명료성이 중요함

- 복사 붙여넣기
    - 중복 제거를 위해 공통 요소를 뽑다 보면 가끔 중복이 아닌 것마저 중복으로 착각하는 경우가 발생하고는 함, 특히 복사 붙여넣기 코드를 작성하다 보면 이런 착각을 자주 하게 됨
    - 실제로 필요하지 않은 코드까지 복사될 때가 있기 때문임
    - 가능하면 복사 붙여넣기를 안하는게 나음

### 소프트웨어 장인 정신
- 깔끔하고 유연해 시간이 지나도 가치를 잃지 않는 코드를 작성하겠다는 일종의 사명을 가져야함
- 변수 이름, 코드 하나를 작성할 때에도 수없이 고민하며 여러 번 고치는 작업을 반복하고 나중에 여러분이 작성한 코드를 다시 볼 때 변수 이름, 함수 이름 선택이 적절했는지, 중복 코드나 일관성 없는 코드는 없는지를 살펴보며 자신의 코드를 계속 갈고 닦아가는 개발자가 되야 함

### 코드 개선을 제안하는 올바른 방법
- 프로젝트에서 개선이 필요한 부분이 발견되었다고 가정함, 이를 개선하기 위해서는?

- 작은 단위의 리팩토링부터 제안
    - 제안하는 리팩토링 작업을 간단하게부터 시작하고 다음 단계인 추가적인 리팩토링을 진행

- 간단한 수준의 개선이 이루어진 이후에는 가능할 때마다 리팩토링을 제안
    - 가능할 때마다 리팩토링 제안, 작더라도 지속해서 코드를 개선해야 팀에 무엇이든 개선하는 문화가 조성됨, 어느 정도 개선 문화가 생겼다 싶을때 전반적인 코드 개선에 관해 논의 시작

- 동료들이 인지하고 있거나 인지할 수 있는 문제 제안
    - 코드에 문제나 비효율이 있다는 걸 확실히 보여줄 수 있고 동료들도 인정해야함

- 현실적인 해결책이 바탕 되어야 함
    - 문제 제시만으로는 부족함, 현실적으로 납득 가능한 수준의 해결책을 함께 제시해야함

- 제안하기 전에 리팩토링 기한과 코드 범위를 사전에 정함
    - 리팩토링을 하다 보면 끝이 없는 작업이 되는 경우가 있음, 의도적으로 리팩토링을 그만둘 마감 일자가 필요함
    - 어떤 클래스나 컴포넌트까지만 개선할 것인가와 같이 코드 베이스의 범위에 대한 제한도 사전에 해둘 필요
    - 이런 제한 사항이 있어야 합리적으로 모두가 좋게 할 수 있음
    
- 동료를 사적으로 공격하지 마라
    - 코드를 왜 이렇게 작성했느냐는 말보단 a는 이래서 b가 더 낫지 않을까요? 라며 기술적인 설명을 곁들여 설득하는 게 좋겠습니다. 코드 리뷰도 마찬가지