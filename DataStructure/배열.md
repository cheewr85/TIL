### 배열이란
- C에서는 배열을 선언하고 크기가 고정되어 있는데, 여기서 값을 저장할 때 연속적으로 메모리에 아래와 같이 저장됨

![picture](/img/DataStructure/Array/one.png)

- 파이썬 리스트는 저장한다면 연속된 공간일 수도 있고 아닐수도 있음, 아래와 같이 2,3,5,7에 대한 래퍼런스 즉 가리키는 래퍼런스를 저장함

![picture](/img/DataStructure/Array/two.png)

- 이러면 값 자체를 저장하는게 아니라 자료들의 크기가 상관이 없음, 아무리 큰 값이어도 가리키는 역할만 하기 때문에
- 그래서 C배열과 다르게 다양한 타입을 저장할 수 있음

### 배열 인덱스를 이용한 데이터 저장/접근법
- 배열에 데이터를 저장하고 가지고 오는 법
- 현재 사용하고 있지 않는 공간에서 16바이트의 공간을 찾고 이 배열에 값을 저장하면 됨, 4개를 저장한다고 하면
- 배열이 요소들이 메모리에 순서대로 그리고 연속적으로 저장됨
- 저장된 데이터를 받아올 때는 그냥 인덱스를 사용하면 됨
- 내부적으로는 인덱스 2 주소는 시작주소가 1000이라고 하면 시작주소 + 데이터크기 x 인덱스 = 1008로 2번 인덱스 주소를 찾을 수 있음
- 이 배열이 시작하는 지점의 주소만 알면 어떤 인덱스든 주소를 쉽게 계산할 수 있음
- 그 값의 주소를 알고 간단하게 계산이 가능하고 O(1)으로 접근할 수 있음, 저장하는 것도 같음(임의 접근 메모리는 O(1)이므로), 배열 인덱스 접근은 주소만 정확히 알면 O(1)만 걸림

### 배열 탐색
- 접근은 인덱스를 통해 값을 찾는 것이고 탐색은 특정 조건을 만족하는 값을 찾는 것임
- 배열에서 탐색은 접근보다 비효율적임, 그 값을 찾기 위해 하나하나 다 확인을 해야하기 때문에
- 순서대로 데이터를 찾는 방식을 선형 탐색이라고 함
- 배열이 특정 순서로 정렬되어 있지 않은 이상 선형 탐색으로 할 수 밖에 없음
- 시간복잡도는 O(n)이 걸림

### 정적 배열
- 정적 배열은 처음 정의할 때 크기를 정해놓고 정해진 크기 이상 값을 추가할 수 없음(크기 고정, 요소 수 제한)
- 동적 배열은 꽉 차도 계속해서 값을 추가할 수 있음(크기 변함, 요소 계속 추가 가능)
- 정적 배열은 꽉 찼을 때 새로운 데이터를 넣을려면 다시 새롭게 새로 추가된 데이터 만큼 배열을 만든 뒤 원래 데이터를 복사하고 추가해야함
- 그렇다고 필요 이상으로 여유롭게 하면 낭비가 생기는 것임

### 동적 배열
- 상황에 맞게 크기가 바뀜
- 꽉차게 된다면 2배 크기의 배열을 만들어서 메모리 공간을 확보한뒤 복사한 다음에 값을 계속해서 추가함
- 동적 배열도 정적 배열로 만들어진 자료 구조임
- 공간이 꽉 찰때마다 정적 배열의 크기를 상황에 맞게 조절하게끔 구현된 것임

### 동적 배열 추가 연산 시간 복잡도
- 배열의 가장 끝에 새 값을 넣는 것을 append operation이라고 함(추가 연산)
- 동적 배열은 내부적으로는 정적 배열을 사용함, 새 값을 추가하려고 할 때 내부적으로 사용 중인 정적 배열에 남은 공간이 있을 수도 있고 꽉 찼을 수도 있음
- 이 두 경우를 나눠서 생각할 수 있음
- 남은 공간이 있을 경우, 비어있는 공간 중에 가장 앞쪽에 데이터를 저장하면 됨 인덱스를 통해 접근시 O(1)이 걸림
- 꽉 차있다고 했을 경우는 값을 추가하기 위해 기존의 배열에 2배로 큰 배열을 예약하고 기존의 배열의 값을 이곳에 다 복사함, 마지막으로 새 값을 비칸에 추가함 → 기존의 저장된 데이터를 n개라고 하면 기존 배열의 인덱스에서 새 배열의 인덱스에 접근해서 붙임 이는 O(n)이 걸림, 그리고 여기서 새 값 추가를 하면 O(n+1) 이자만 O(n)이라고 볼 수 있음
- 즉 최고의 경우 O(1), 최악의 경우 O(n)이 걸림

### 분할 상환 분석 개념
- 시간 복잡도는 보통 최악의 경우로 계산함
- 최고의 경우는 자주 일어나지만 최악의 경우는 가끔 일어남
- 동적 배열 추가 연산을 O(n)이 걸린다고 하면 조금은 비합리적임
- 이런 상황을 위해 시간 복잡도를 조금 다르게 계산함 → 분할 상환 분석(Amortized Analysis), 할부를 뜻함
- 같은 동작을 n번 했을 때 드는 시간이 X일 때, 동작을 한 번 하는 데 걸린 시간은 X/n으로 할 수 있음, 즉 평균을 내서 이야기 하는 것임
- 연속으로 추가 연산을 n번을 하면 데이터를 옮겨서 저장하는 데 걸리는 총 시간은 2n보다 작음
- 동적 배열의 추가 연산은 최악의 경우 O(n)이 걸리지만, 분할 상환 분석을 하면 O(1)이 걸림

### 동적 배열 삽입 연산
- 삽입 연산 → 배열의 아무 위치에나 데이터를 더해주는 것
- 추가와 마찬가지로 여유 공간 있을 때 꽉 찼을 때로 나뉨
- 여유 공간이 있을때는 중간에 새로운 요소를 저장하기 위해 해당 인덱스와 해당 인덱스 뒤의 값들을 한 인덱스 뒤로 미뤄야함, 그리고 여기서 생기는 빈 공간에 저장을 함 → 이 경우 시간 복잡도는 최악의 경우는 n개의 데이터를 일일이 미루는 경우임 O(1) x n → O(n)이 걸림 → 삽입도 걸리므로 O(n+1)임 → 이는 O(n)임
- 배열이 꽉 찬 경우에는 공간이 부족하므로 새로운 배열을 만들고 기존 데이터를 복사해서 저장한 다음에 인덱스를 뒤로 민 다음에 해당 자리에 저장을 함 → n개의 요소가 있을 때 만들고 새로 저장하는게 O(n)이 걸리고 원하는 위치에 공간을 만들 때 한 칸 씩 뒤로 미루면 최악의 경우 0에 삽입 하는 것이므로 O(n)이 걸림 → 그 다음 새로운 데이터를 저장함 → 이를 보면 O(n) + O(n) + O(1)이 걸림 → 총 O(2n+1) → O(n)임
- 둘 다 최악의 경우 O(n)임 시간 복잡도는 즉 O(n)이라는 것, 아무 위치 삽입시 O(n)이 걸리는 것

### 동적 배열 삭제 연산
- 데이터를 삭제할 때는 동적 배열에서 접근할 수 있는 인덱스 범위도 줄임
- 그리고 모든 데이터 요소를 한칸씩 앞으로 밀어서 저장함
- 결과적으로 아무 위치에 데이터를 삭제할 때는 원하는 위치 뒤에 있는 데이터를 옮겨 저장해야 하므로 최악의 경우는 O(n)이고 가장 뒤에 있는 데이터를 삭제할 때는 다른 데이터를 옮겨 저장할 필요가 없으므로 이때는 O(1)임

### 동적 배열 크기 줄이기
- 동적 배열은 요소의 개수가 어느정도 줄어들면 내부 배열의 크기도 적절히 줄여서 공간을 좀 더 효율적으로 사용함
- 크기를 줄일 때는 내부 배열의 사용 비율이 특정 값 이하로 떨어질 때임
- 여기서도 마찬가지로 내부 배열의 크기가 줄어드는 건 드문 경우임 그래서 대부분의 경우 삭제할 때 O(1)이 걸리고 드물게 O(n)이 걸림, 분할 상환 분석을 통해 삭제 연산도 O(1)이 걸린다고 할 수 있음

### 배열과 동적 배열 정리/비교
- 연산 & 시간 복잡도

![picture](/img/DataStructure/Array/three.png)

- 낭비하는 공간
- 배열은 크기가 고정되어 있기 때문에 낭비하는 공간이 없음
- 동적 배열은 공간을 낭비할 수도 있고 안 할 수도 있음 → O(n)이 낭비될 수 있음

### 배열에 데이터 삽입과 삭제를 못하는 이유
- 크기가 고정되어 있는 배열에는 처음 정한 수보다 더 많은 데이터를 삽입할 수가 없음
- 지우고 싶은 요소를 자연스럽게 삭제할 수도 없음